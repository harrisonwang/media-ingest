// media-ingest (mingest) - Media Ingestion CLI tool
// Copyright (C) 2026  Harrison Wang <https://mingest.com>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published
// by the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

package ingest

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"time"
)

func filterCookieFileForPlatform(path string, p videoPlatform) error {
	if strings.TrimSpace(path) == "" {
		return nil
	}
	// If not configured, don't filter (privacy vs. correctness trade-off).
	// We only persist filtered cookies for known platforms.
	if strings.TrimSpace(p.ID) == "" || len(p.CookieDomainSuffixes) == 0 {
		return nil
	}
	return filterNetscapeCookieFile(path, p.AllowsCookieDomain)
}

func filterNetscapeCookieFile(path string, allowDomain func(string) bool) error {
	in, err := os.Open(path)
	if err != nil {
		return err
	}

	var kept []string
	sc := bufio.NewScanner(in)
	// Cookies can contain long values.
	sc.Buffer(make([]byte, 0, 64*1024), 1024*1024)

	const httpOnlyPrefix = "#HttpOnly_"
	for sc.Scan() {
		line := strings.TrimRight(sc.Text(), "\r")
		if strings.TrimSpace(line) == "" {
			continue
		}

		work := line
		if strings.HasPrefix(work, httpOnlyPrefix) {
			work = strings.TrimPrefix(work, httpOnlyPrefix)
		} else if strings.HasPrefix(work, "#") {
			// Normal comment line (keep none; we write our own header).
			continue
		}

		parts := strings.Split(work, "\t")
		if len(parts) < 7 {
			continue
		}
		domain := parts[0]
		if !allowDomain(domain) {
			continue
		}
		kept = append(kept, line)
	}
	if err := sc.Err(); err != nil {
		_ = in.Close()
		return err
	}
	if err := in.Close(); err != nil {
		return err
	}

	dir := filepath.Dir(path)
	tmp, err := os.CreateTemp(dir, "mingest-cookies-*.tmp")
	if err != nil {
		return err
	}
	tmpPath := tmp.Name()
	defer func() { _ = os.Remove(tmpPath) }()

	_, _ = fmt.Fprintln(tmp, "# Netscape HTTP Cookie File")
	_, _ = fmt.Fprintln(tmp, "# This file was generated by mingest. DO NOT EDIT.")
	_, _ = fmt.Fprintln(tmp)

	for _, line := range kept {
		_, _ = fmt.Fprintln(tmp, line)
	}
	if err := tmp.Close(); err != nil {
		return err
	}

	// Best-effort: keep the file private. Windows ignores chmod.
	_ = os.Chmod(tmpPath, 0o600)

	if err := replaceFile(tmpPath, path); err != nil {
		return err
	}
	_ = os.Chmod(path, 0o600)
	return nil
}

func replaceFile(srcPath, dstPath string) error {
	// On Unix, rename is atomic and replaces the destination.
	if runtime.GOOS != "windows" {
		return os.Rename(srcPath, dstPath)
	}

	// On Windows, file replacement can be flaky when AV/indexers briefly hold the destination.
	// Retry a few times with backoff; this is best-effort (privacy), not required for download.
	var lastErr error
	for i := 0; i < 10; i++ {
		// Try direct rename first (Go uses MoveFileEx with replace semantics where possible).
		if err := os.Rename(srcPath, dstPath); err == nil {
			return nil
		} else {
			lastErr = err
		}

		_ = os.Remove(dstPath)
		if err := os.Rename(srcPath, dstPath); err == nil {
			return nil
		} else {
			lastErr = err
		}

		time.Sleep(time.Duration(25*(i+1)) * time.Millisecond)
	}
	return lastErr
}

func createTempCookieJarFile(dir string) (string, func(), error) {
	if strings.TrimSpace(dir) == "" {
		dir = os.TempDir()
	}
	if err := os.MkdirAll(dir, 0o700); err != nil {
		return "", nil, err
	}

	f, err := os.CreateTemp(dir, "mingest-ytdlp-cookies-*.txt")
	if err != nil {
		return "", nil, err
	}
	path := f.Name()
	// Write a minimal valid Netscape header so yt-dlp can load the jar even when empty.
	_, _ = fmt.Fprintln(f, "# Netscape HTTP Cookie File")
	_, _ = fmt.Fprintln(f, "# This file was generated by mingest. DO NOT EDIT.")
	_, _ = fmt.Fprintln(f)
	if err := f.Close(); err != nil {
		_ = os.Remove(path)
		return "", nil, err
	}

	_ = os.Chmod(path, 0o600)
	cleanup := func() { _ = os.Remove(path) }
	return path, cleanup, nil
}

func cookieFileLooksLikeAuthenticated(path string, p videoPlatform) (bool, error) {
	if strings.TrimSpace(path) == "" {
		return false, nil
	}
	if len(p.AuthCookieNames) == 0 {
		return false, nil
	}

	in, err := os.Open(path)
	if err != nil {
		return false, err
	}
	defer in.Close()

	sc := bufio.NewScanner(in)
	sc.Buffer(make([]byte, 0, 64*1024), 1024*1024)

	const httpOnlyPrefix = "#HttpOnly_"
	for sc.Scan() {
		line := strings.TrimRight(sc.Text(), "\r")
		if strings.TrimSpace(line) == "" {
			continue
		}

		work := line
		if strings.HasPrefix(work, httpOnlyPrefix) {
			work = strings.TrimPrefix(work, httpOnlyPrefix)
		} else if strings.HasPrefix(work, "#") {
			continue
		}

		parts := strings.Split(work, "\t")
		if len(parts) < 7 {
			continue
		}
		domain := parts[0]
		name := parts[5]
		value := parts[6]

		if !p.AllowsCookieDomain(domain) {
			continue
		}

		for _, want := range p.AuthCookieNames {
			if name == want && strings.TrimSpace(value) != "" {
				return true, nil
			}
		}
	}
	if err := sc.Err(); err != nil {
		return false, err
	}
	return false, nil
}

func copyFileAtomic(srcPath, dstPath string) error {
	b, err := os.ReadFile(srcPath)
	if err != nil {
		return err
	}

	dir := filepath.Dir(dstPath)
	if err := os.MkdirAll(dir, 0o700); err != nil {
		return err
	}
	tmp, err := os.CreateTemp(dir, "mingest-cookies-copy-*.tmp")
	if err != nil {
		return err
	}
	tmpPath := tmp.Name()
	defer func() { _ = os.Remove(tmpPath) }()

	if _, err := tmp.Write(b); err != nil {
		_ = tmp.Close()
		return err
	}
	if err := tmp.Close(); err != nil {
		return err
	}
	_ = os.Chmod(tmpPath, 0o600)
	if err := replaceFile(tmpPath, dstPath); err != nil {
		return err
	}
	_ = os.Chmod(dstPath, 0o600)
	return nil
}
